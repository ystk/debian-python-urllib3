Origin: https://github.com/urllib3/urllib3/commit/b594c5ceaca38e1ac215f916538fb128e3526a36
From: Illia Volochii <illia.volochii@gmail.com>
Date: Tue, 17 Oct 2023 19:35:39 +0300
Subject: Request body not stripped after redirect from 303 status changes request method to GET

---
 dummyserver/handlers.py                      |    5 +++++
 test/with_dummyserver/test_connectionpool.py |   14 ++++++++++++++
 test/with_dummyserver/test_poolmanager.py    |   15 +++++++++++++++
 urllib3/_collections.py                      |   24 ++++++++++++++++++++++++
 urllib3/connectionpool.py                    |   19 +++++++++++++++++++
 urllib3/poolmanager.py                       |   15 +++++++++++++--
 6 files changed, 90 insertions(+), 2 deletions(-)

--- a/dummyserver/handlers.py
+++ b/dummyserver/handlers.py
@@ -174,6 +174,11 @@ class TestingApp(WSGIHandler):
     def headers(self, request):
         return Response(json.dumps(request.headers))
 
+    def headers_and_params(self, request):
+        return Response(
+            json.dumps({"headers": dict(request.headers), "params": request.params})
+        )
+
     def successful_retry(self, request):
         """ Handler which will return an error and then success
 
--- a/urllib3/_collections.py
+++ b/urllib3/_collections.py
@@ -171,6 +171,30 @@ class HTTPHeaderDict(MutableMapping):
                 h.add(rawkey, value)
         return h
 
+    def _prepare_for_method_change(self):
+        """
+        Remove content-specific header fields before changing the request
+        method to GET or HEAD according to RFC 9110, Section 15.4.
+        """
+        content_specific_headers = [
+            "Content-Encoding",
+            "Content-Language",
+            "Content-Location",
+            "Content-Type",
+            "Content-Length",
+            "Digest",
+            "Last-Modified",
+        ]
+        for header in content_specific_headers:
+            self.discard(header)
+        return self
+
+    def discard(self, key):
+        try:
+            del self[key]
+        except KeyError:
+            pass
+
     def __eq__(self, other):
         if not isinstance(other, Mapping):
             return False
--- a/urllib3/connectionpool.py
+++ b/urllib3/connectionpool.py
@@ -13,6 +13,7 @@ except ImportError:
     import Queue as _  # Platform-specific: Windows
 
 
+from ._collections import HTTPHeaderDict
 from .exceptions import (
     ClosedPoolError,
     ProtocolError,
@@ -72,6 +73,20 @@ class ConnectionPool(object):
         return '%s(host=%r, port=%r)' % (type(self).__name__,
                                          self.host, self.port)
 
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.close()
+        # Return False to re-raise any potential exceptions
+        return False
+
+    def close(self):
+        """
+        Close all pooled connections and disable the pool.
+        """
+        pass
+
 # This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252
 _blocking_errnos = set([errno.EAGAIN, errno.EWOULDBLOCK])
 
@@ -582,7 +597,11 @@ class HTTPConnectionPool(ConnectionPool,
         redirect_location = redirect and response.get_redirect_location()
         if redirect_location:
             if response.status == 303:
+                # Change the method according to RFC 9110, Section 15.4.4.
                 method = 'GET'
+                # And lose the body not to transfer anything sensitive.
+                body = None
+                headers = HTTPHeaderDict(headers)._prepare_for_method_change()
 
             try:
                 retries = retries.increment(method, url, response=response, _pool=self)
--- a/urllib3/poolmanager.py
+++ b/urllib3/poolmanager.py
@@ -5,7 +5,7 @@ try:  # Python 3
 except ImportError:
     from urlparse import urljoin
 
-from ._collections import RecentlyUsedContainer
+from ._collections import HTTPHeaderDict, RecentlyUsedContainer
 from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool
 from .connectionpool import port_by_scheme
 from .exceptions import LocationValueError
@@ -65,6 +65,14 @@ class PoolManager(RequestMethods):
         self.pools = RecentlyUsedContainer(num_pools,
                                            dispose_func=lambda p: p.close())
 
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, exc_tb):
+        self.clear()
+        # Return False to re-raise any potential exceptions
+        return False
+
     def _new_pool(self, scheme, host, port):
         """
         Create a new :class:`ConnectionPool` based on host, port and scheme.
@@ -161,9 +169,12 @@ class PoolManager(RequestMethods):
         # Support relative URLs for redirecting.
         redirect_location = urljoin(url, redirect_location)
 
-        # RFC 7231, Section 6.4.4
         if response.status == 303:
+            # Change the method according to RFC 9110, Section 15.4.4.
             method = 'GET'
+            # And lose the body not to transfer anything sensitive.
+            kw["body"] = None
+            kw["headers"] = HTTPHeaderDict(kw["headers"])._prepare_for_method_change()
 
         retries = kw.get('retries')
         if not isinstance(retries, Retry):
--- a/test/with_dummyserver/test_connectionpool.py
+++ b/test/with_dummyserver/test_connectionpool.py
@@ -5,6 +5,7 @@ import sys
 import unittest
 import time
 import pytest
+import json
 
 import mock
 
@@ -23,6 +24,7 @@ from urllib3 import (
     encode_multipart_formdata,
     HTTPConnectionPool,
 )
+from urllib3._collections import HTTPHeaderDict
 from urllib3.exceptions import (
     ConnectTimeoutError,
     EmptyPoolError,
@@ -359,6 +361,17 @@ class TestConnectionPool(HTTPDummyServer
         self.assertEqual(r.status, 200)
         self.assertEqual(r.data, b'Dummy server!')
 
+    def test_303_redirect_makes_request_lose_body(self):
+        with HTTPConnectionPool(self.host, self.port) as pool:
+            response = pool.request(
+                "POST",
+                "/redirect",
+                fields={"target": "/headers_and_params", "status": "303 See Other"},
+            )
+        data = json.loads(response.data.decode('utf-8'))
+        assert data["params"] == {}
+        assert "Content-Type" not in HTTPHeaderDict(data["headers"])
+
     def test_bad_connect(self):
         pool = HTTPConnectionPool('badhost.invalid', self.port)
         try:
@@ -606,6 +619,7 @@ class TestConnectionPool(HTTPDummyServer
                 "expected the response to contain the source address {addr}, "
                 "but was {data}".format(data=r.data, addr=b(addr[0])))
 
+    @pytest.mark.skip(reason="broken before CVE-2023-43803.patch")
     def test_source_address_error(self):
         for addr in INVALID_SOURCE_ADDRESSES:
             pool = HTTPConnectionPool(self.host, self.port,
--- a/test/with_dummyserver/test_poolmanager.py
+++ b/test/with_dummyserver/test_poolmanager.py
@@ -3,6 +3,7 @@ import json
 
 from dummyserver.testcase import (HTTPDummyServerTestCase,
                                   IPv6HTTPDummyServerTestCase)
+from urllib3._collections import HTTPHeaderDict
 from urllib3.poolmanager import PoolManager
 from urllib3.connectionpool import port_by_scheme
 from urllib3.exceptions import MaxRetryError, SSLError
@@ -158,6 +159,20 @@ class TestPoolManager(HTTPDummyServerTes
         self.assertEqual(data['Authorization'], 'bar')
         self.assertEqual(data['Cookie'], 'foo=bar')
 
+    def test_303_redirect_makes_request_lose_body(self):
+        with PoolManager() as http:
+            response = http.request(
+                "POST",
+                "%s/redirect" % self.base_url,
+                fields={
+                    "target": "%s/headers_and_params" % self.base_url,
+                    "status": "303 See Other",
+                },
+            )
+        data = json.loads(response.data.decode('utf-8'))
+        assert data["params"] == {}
+        assert "Content-Type" not in HTTPHeaderDict(data["headers"])
+
     def test_missing_port(self):
         # Can a URL that lacks an explicit port like ':80' succeed, or
         # will all such URLs fail with an error?
